---

layout:     post
title:      HUI-Miner算法
subtitle:   
date:       2022-01-05
author:     Jialong
header-img: 
catalog: 	true
tags:
    - high utility itemset
    - mining algorithm
---

> # HUI-Miner算法



## 0. 算法提出的背景

- 频繁项集挖掘的局限性：频繁项集挖掘的任务就是挖掘出事务数据库中的频繁项集，即挖掘出在客户的交易数据库中频繁出现的项目的组合。但频繁项集挖掘算法不能考虑到有关物品的购买数量和物品的单位利润，只能找到频繁出现的项集，而不是那些能够产生高利润的项集。算法最终可能会挖掘出许多产生低利润的频繁项集，同时可能会错过许多产生高利润的稀有项集。因此，学术界相关学者提出了同时考虑项目出现频次和项目重要度的高效用项集挖掘算法。
- 2005年 Liu等人提出了Two-Phase算法，该算法通过事务加权效用向下封闭的性质来挖掘所有的高效用项集。挖掘过程分两个阶段，第1阶段，使用层次遍历和向上估计项集效用值的方式来搜索项集的搜索空间，进而生成候选高效用项集。在第2阶段，扫描事务数据库，计算候选项集的效用值并与效用阈值作比较输出所有的高效用项集。但是该算法有一个重要的缺点,它需要生成大量的候选项集,算法效率较低。



## 1. 高效用项集挖掘的预备知识

令 $I =\{i_1,i_2,…,i_n\}$ 是一个有限的项目集合。事务数据库 $DB$ 一般由1个事务表和1个外部效用表构成。事务表是由多个事务$\{T_1，T_2…，T_n\}$构成的。同时，每一个事务 $T$。都有一个唯一的标识符 $T_{id}$。对于每个事务 $T_c$ 中的每个项目 $i\in T_c$，都有一个与之对应的正整数 $iu(i,T_c)$，称为**内部效用**(表示购买数量等)。外部效用表中，则保存了每个项目对应的 **外部效用**  $eu(i)$ (表示单位利润等)。**项集**是由若干个项目构成的一个集合，包含k个项目的集合一般被称为**k-项集**。

如下图所示，给出1个事务数据库。这个事务数据库包含7条互不相同的事务 $(T_1,T_2,...,T_7)$。在事务 $T_2$ 中包含项目(a, b, c, d, e)，并且它的内部效用值分别为(4,1,3,1,1)。其中，事务 $T_2$ 中项目b对应的内部效用为1，表示事务 $T_2$ 中b出现了1次。从图中可得，事务 $T_2$ 中这些项目的外部效用为(1,2,1,5,4)。

![](https://raw.githubusercontent.com/Jialong-c/images/master/Blog/HUI-Miner算法/database.png)

- **项目的事务效用 $u(i,T_c)$**：在事务 $T_c$ 中，项目的外部效用和内部效用的乘积,即
  $$
  u(i,T_c)=eu(i)*iu(i,T_c)
  $$

- **项集效用 $u(X)$**：寻找项集 $X$ 所在的事务，分别计算求和

- **高效用项集挖掘问题**：令 $minutil$ 为指定的最小效用阈值，如果项集 $X$ 的效用大于等于 $minutil$ ，那么该项集为高效用项集

- **事务效用 $tu(T_c)$**：事务 $T_c$ 中各项目的事务效用之和，即
  $$
  tu(T_c)=\sum_{i\in T_c}u(i,T_c)
  $$

![](https://raw.githubusercontent.com/Jialong-c/images/master/Blog/HUI-Miner算法/tu.png)

- **项集的事务加权效用 $twu(X)$** ：包含项集 $X$ 的事务效用之和

![](https://raw.githubusercontent.com/Jialong-c/images/master/Blog/HUI-Miner算法/twu.png)

- 事务加权效用的三个重要性质：
  - 性质1：令项集 $X$ ，则有 $twu(X)\ge u(X)$ 
  
  - 性质2：令项集 $X、 Y$ ，如果 $X\subseteq Y$，则有 $twu(X)\ge twu(Y)$，这说明事务加权效用是反单调的
  
  - 性质3：令项集 $X$​ ，如果 $twu(X)<minutil$​ ，那么项集 $X$​ 和它的超集都是低效用项集
    $$
    if\quad X\subseteq X',\quad then\quad u(X')\leq twu(X')\leq twu(X)<minutil
    $$



## 2. 效用列表

### 2.1 初始化效用列表

首先，通过第一次扫描数据库计算所有项目的事务加权效用。如果一个项目的事务加权效用小于给定的 $minutil$，那么根据性质1，在随后的挖掘过程中不再考虑该项目及其超集。对于事务加权效用大于$minutil$ 的项目，按照事务加权效用递增的顺序进行排序。对于图中的数据库，假设 $minutil$ 为30，则算法在第一次数据库扫描后不再考虑 $f$ 和 $g$ 项，删去这两项，如下图。其余的项目排序为 $e<c<b<a<d$ 

![](https://raw.githubusercontent.com/Jialong-c/images/master/Blog/HUI-Miner算法/database2.png)

定义：

- 排序事务 $T_c$ 中项集 $X$ 之后的所有项目的组合，记为 $T_c/X$ ，例如：$T_2 / \{eb\}=\{ad\}$

- **效用元组 $ut(X,T_c)$​**：由事务标识符、某项集的事务效用和事务中该项集之后项目的事务效用的总和构成的一个三元组，称为效用元组。
  $$
  ut(X,T_c)=(tid,iutil,rutil)
  $$

通过对数据库的第二次扫描，可以得到下图所示的效用列表

![](https://raw.githubusercontent.com/Jialong-c/images/master/Blog/HUI-Miner算法/效用列表.png)

### 2.2 2-项集效用列表

无需再次扫描数据库，通过比较两个项目对应效用列表中的 $tid$，取交集生成新的2-项集效用列表

![](https://raw.githubusercontent.com/Jialong-c/images/master/Blog/HUI-Miner算法/2项集效用列表.png)

### 2.3 $k$-项集效用列表 $k\ge 3$

具体方法和二元计算类似，从二元项集中选取项，如 $\{eb\} $与 $\{ea\}$ 可以生成 $\{eba\}$，但需要注意的是，计算之间有重叠部分 $\{e\}$，所以还要减去 $u(e, T_c)$

![](https://raw.githubusercontent.com/Jialong-c/images/master/Blog/HUI-Miner算法/3项集效用列表.png)



## 3.HUI-Miner算法

### 3.1 检索空间

使用枚举树结构，每个节点按 $twu$ 值顺序如下：

![](https://raw.githubusercontent.com/Jialong-c/images/master/Blog/HUI-Miner算法/枚举树.png)

### 3.2 剪枝策略

利用效用列表的两个重要性质：

- 令项集 $X$，$X$ 的效用列表中所有效用元组的 $iutil$ 的和，即该项集 $X$ 在事务数据库中的总效用。因此，如果求和得到的结果大于等于 $minutil$，那么 $X$ 是一个高效用项集。反之，$X$ 是一个低效用项集
- 令项集 $X$，如果$X$ 的效用列表中所有效用元组的 $iutil$ 和 $rutil$ 的和小于 $minutil$，那么 $X$ 和 $X$ 的所有扩展项集都是低效用项集

### 3.3 实现细节

- 为了提高效率，避免对效用列表的扫描。在构建效用列表的同时对 $iutils$ 与 $rutils$ 的总和进行计算并保存在效用列表中。

- 也不需要将项集与相应的效用列表绑定起来，因为集枚举树中某节点的所有子节点表示的项目集都具有相同的前缀项集。

- 效用列表中的第一行存储扩展项以及 $iutils$ 和 $rutils$ 的和，而前缀项集为独立存储。

![](https://raw.githubusercontent.com/Jialong-c/images/master/Blog/HUI-Miner算法/效用列表实现.png)

## 参考文献

1. Liu M, Qu J. Mining high utility itemsets without candidate generation[C]//Proceedings of the 21st ACM international conference on Information and knowledge management. 2012: 55-64.
2. 尹松林. 改进的高效用项集挖掘算法研究[D]. 燕山大学,2019.
